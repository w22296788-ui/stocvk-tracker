<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Family Investment League &ndash; 2026</title>
  <!--
    Cloudflare Pages deploy:
    1) Drag-and-drop this folder into Cloudflare Pages, or
    2) Push to GitHub and connect the repo in Cloudflare Pages.
    Then add TWELVE_DATA_API_KEY to the Pages environment variables.
    No build step required.
  -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap');

    :root {
      color-scheme: light;
      --bg: #eef3f8;
      --bg-elevated: #ffffff;
      --ink: #0b1320;
      --muted: #5b6674;
      --border: #dbe3ec;
      --positive: #0a7a4b;
      --negative: #b33b2e;
      --accent: #0f3c5a;
      --accent-2: #0c8b6a;
      --accent-soft: rgba(15, 60, 90, 0.12);
      --accent-2-soft: rgba(12, 139, 106, 0.14);
      --chart-grid: #e1e7ef;
      --shadow: 0 24px 60px rgba(10, 28, 44, 0.16);
      --shadow-soft: 0 14px 36px rgba(10, 28, 44, 0.1);
      --radius: 18px;
      --radius-sm: 12px;
      --space-1: 8px;
      --space-2: 12px;
      --space-3: 16px;
      --space-4: 24px;
      --space-5: 32px;
      --space-6: 44px;
      --max-width: 1200px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "IBM Plex Sans", "SF Pro Text", "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 700px at 12% -8%, rgba(15, 60, 90, 0.12), transparent 60%),
        radial-gradient(900px 540px at 92% 6%, rgba(12, 139, 106, 0.1), transparent 65%),
        linear-gradient(180deg, #f9fbfd 0%, var(--bg) 100%);
      color: var(--ink);
    }

    .app {
      max-width: var(--max-width);
      margin: 0 auto;
      padding: 48px 32px 64px;
    }

    header.top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: var(--space-4);
      margin-bottom: var(--space-4);
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(15, 60, 90, 0.08);
      border-radius: 22px;
      padding: 20px 24px;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(10px);
    }

    h1 {
      margin: 0 0 var(--space-1);
      font-size: 32px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .subtext {
      color: var(--muted);
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .status {
      font-size: 12px;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 60, 90, 0.08);
    }

    .status[data-level="warn"] {
      color: var(--negative);
      background: rgba(179, 59, 46, 0.1);
    }

    .status[data-level="ok"] {
      color: var(--positive);
      background: rgba(12, 139, 106, 0.12);
    }

    .status:empty {
      display: none;
    }

    .error-panel {
      margin-bottom: var(--space-4);
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(179, 59, 46, 0.2);
      background: rgba(179, 59, 46, 0.08);
      color: var(--ink);
      display: none;
    }

    .error-panel.active {
      display: block;
    }

    .error-panel h3 {
      margin: 0 0 var(--space-1);
      font-size: 14px;
      letter-spacing: 0.02em;
    }

    .error-panel ul {
      margin: 0;
      padding-left: 18px;
      color: var(--ink);
    }

    .error-panel li {
      margin: 4px 0;
      font-size: 13px;
      color: var(--ink);
    }

    .error-panel .error-meta {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: var(--space-1);
    }

    .actions {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    button {
      border: 1px solid transparent;
      background: linear-gradient(135deg, #0f3c5a 0%, #1f6d82 100%);
      color: #fff;
      padding: 12px 18px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      box-shadow: 0 10px 24px rgba(15, 60, 90, 0.22);
    }

    button:disabled {
      cursor: default;
      opacity: 0.7;
      transform: none;
      box-shadow: none;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: var(--shadow);
    }

    .leader-card {
      background: linear-gradient(135deg, #ffffff 0%, #f1f7fb 100%);
      border: 1px solid rgba(15, 60, 90, 0.12);
      border-radius: var(--radius);
      padding: var(--space-4) var(--space-5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--space-4);
      margin-bottom: var(--space-5);
      box-shadow: var(--shadow);
    }

    .leader-card.empty {
      opacity: 0.65;
    }

    .leader-label {
      display: inline-flex;
      align-items: center;
      gap: var(--space-1);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--accent);
      margin-bottom: var(--space-2);
    }

    .leader-name {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: var(--space-1);
    }

    .leader-return {
      font-size: 46px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .leader-return.positive {
      color: var(--positive);
    }

    .leader-return.negative {
      color: var(--negative);
    }

    .leader-details {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: var(--space-3);
      min-width: 320px;
    }

    .detail-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .detail-value {
      margin-top: 6px;
      font-size: 16px;
      font-weight: 500;
    }

    main.grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-template-areas:
        "leaderboard bar"
        "line line";
      gap: var(--space-4);
    }

    .card {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(15, 60, 90, 0.08);
      border-radius: var(--radius);
      padding: var(--space-4);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(6px);
    }

    .card-header {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: var(--space-3);
    }

    .card-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .card-header p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }

    .leaderboard {
      grid-area: leaderboard;
    }

    .chart-card {
      grid-area: bar;
      min-height: 320px;
      display: flex;
      flex-direction: column;
    }

    .line-card {
      grid-area: line;
      min-height: 340px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th {
      text-align: left;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      padding-bottom: var(--space-2);
    }

    td {
      padding: var(--space-2) 0;
      border-top: 1px solid var(--border);
      vertical-align: middle;
    }

    tr:first-child td {
      border-top: none;
    }

    .rank-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 60, 90, 0.08);
      font-weight: 600;
      font-size: 13px;
    }

    .leader-row .rank-pill {
      background: rgba(29, 59, 87, 0.12);
      color: var(--accent);
    }

    .name-cell {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .name-cell .name {
      font-weight: 600;
    }

    .name-cell .tickers {
      font-family: "IBM Plex Mono", "SFMono-Regular", monospace;
      font-size: 12px;
      color: var(--muted);
    }

    .avg-return {
      font-size: 20px;
      font-weight: 600;
    }

    .avg-return.positive {
      color: var(--positive);
    }

    .avg-return.negative {
      color: var(--negative);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--accent-2-soft);
      color: var(--accent-2);
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
    }

    .badge.negative {
      background: rgba(179, 59, 46, 0.12);
      color: var(--negative);
    }

    .empty-state {
      padding: var(--space-4) 0;
      color: var(--muted);
      font-size: 14px;
    }

    .chart-wrap {
      position: relative;
      flex: 1;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }


    .footer {
      margin-top: var(--space-5);
      display: flex;
      flex-direction: column;
      gap: var(--space-1);
      color: var(--muted);
      font-size: 12px;
    }

    .rank-change {
      animation: pulse 1.6s ease;
    }

    tbody tr {
      transition: background 0.2s ease;
    }

    tbody tr:hover {
      background: rgba(15, 60, 90, 0.04);
    }

    @keyframes pulse {
      0% {
        background: rgba(29, 59, 87, 0.08);
      }
      100% {
        background: transparent;
      }
    }

    @media (max-width: 1000px) {
      header.top {
        flex-direction: column;
        align-items: flex-start;
      }

      .leader-card {
        flex-direction: column;
        align-items: flex-start;
      }

      .leader-details {
        width: 100%;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 900px) {
      main.grid {
        grid-template-columns: 1fr;
        grid-template-areas:
          "leaderboard"
          "bar"
          "line";
      }
    }

    @media (max-width: 600px) {
      .app {
        padding: 32px 20px 48px;
      }

      .leader-details {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="top">
      <div>
        <h1>Family Investment League &ndash; 2026</h1>
        <div class="subtext">
          <span>Last updated: <strong id="lastUpdated">--:--</strong></span>
          <span>Start locked: <strong id="lockDate">--</strong></span>
          <span class="status" id="statusLine" aria-live="polite"></span>
        </div>
      </div>
      <div class="actions">
        <button id="refreshBtn">Refresh Prices</button>
      </div>
    </header>

    <section class="error-panel" id="errorPanel" aria-live="polite"></section>

    <section class="leader-card empty" id="leaderCard">
      <div>
        <div class="leader-label">
          <span aria-hidden="true" id="leaderCrown"></span>
          Current Leader
        </div>
        <div class="leader-name" id="leaderName">No participants yet</div>
        <div class="leader-return" id="leaderReturn">--%</div>
      </div>
      <div class="leader-details" id="leaderDetails">
        <div>
          <div class="detail-label">Portfolio avg</div>
          <div class="detail-value" id="leaderAvg">--%</div>
        </div>
        <div>
          <div class="detail-label">Best stock</div>
          <div class="detail-value" id="leaderBest">--</div>
        </div>
        <div>
          <div class="detail-label">Start date</div>
          <div class="detail-value" id="leaderStart">--</div>
        </div>
      </div>
    </section>

    <main class="grid">
      <section class="card leaderboard">
        <div class="card-header">
          <h2>Leaderboard</h2>
          <p>Average return across two picks</p>
        </div>
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>Name</th>
              <th>Avg % Return</th>
              <th>Best Stock</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>
      </section>

      <section class="card chart-card">
        <div class="card-header">
          <h2>Average Return</h2>
          <p>Performance by participant</p>
        </div>
        <div class="chart-wrap">
          <canvas id="barChart"></canvas>
        </div>
      </section>

      <section class="card chart-card line-card">
        <div class="card-header">
          <h2>Portfolio Trend</h2>
          <p>Average return over time</p>
        </div>
        <div class="chart-wrap">
          <canvas id="lineChart"></canvas>
        </div>
      </section>
    </main>

    <footer class="footer">
      <div>Data source: Twelve Data daily time series via Cloudflare Pages Function (API key required).</div>
      <div>Deploy: Cloudflare Pages + set <strong>TWELVE_DATA_API_KEY</strong> in project environment variables.</div>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script>
    (() => {
      const API_ENDPOINT = './api/league';
      const LEAGUE_START_DATE = '2026-01-01';
      const MAX_HISTORY = 260;
      const LOCAL_CACHE_KEY = 'leagueCache.v1';
      const FALLBACK_TTL_MS = 24 * 60 * 60 * 1000;
      const PARTICIPANTS = [
        { id: 'tucker', name: 'Tucker', tickers: ['DC', 'GOOG'] },
        { id: 'macy', name: 'Macy', tickers: ['IBM', 'SOFI'] },
        { id: 'will', name: 'Will', tickers: ['NVDA', 'AMZN'] },
        { id: 'syd', name: 'Syd', tickers: ['LLY', 'NVDA'] },
        { id: 'tara', name: 'Tara', tickers: ['TTWO', 'PLTR'] },
        { id: 'foster', name: 'Foster', tickers: ['GOOGL', 'AVGO'] },
        { id: 'hunter', name: 'Hunter', tickers: ['MSFT', 'AZO'] },
        { id: 'everett', name: 'Everett', tickers: ['VZ', 'HD'] }
      ];
      const chartColors = [
        '#1d3b57',
        '#0a7a4b',
        '#9c6b2f',
        '#6b4f4f',
        '#2f5c73',
        '#3b6f5c',
        '#7a3f2b',
        '#3f5668'
      ];

      const dom = {
        lastUpdated: document.getElementById('lastUpdated'),
        lockDate: document.getElementById('lockDate'),
        statusLine: document.getElementById('statusLine'),
        errorPanel: document.getElementById('errorPanel'),
        refreshBtn: document.getElementById('refreshBtn'),
        leaderCard: document.getElementById('leaderCard'),
        leaderCrown: document.getElementById('leaderCrown'),
        leaderName: document.getElementById('leaderName'),
        leaderReturn: document.getElementById('leaderReturn'),
        leaderAvg: document.getElementById('leaderAvg'),
        leaderBest: document.getElementById('leaderBest'),
        leaderStart: document.getElementById('leaderStart'),
        leaderboardBody: document.getElementById('leaderboardBody'),
        barChart: document.getElementById('barChart'),
        lineChart: document.getElementById('lineChart')
      };

      let barChartInstance;
      let lineChartInstance;
      let isRefreshing = false;
      let lastRanks = {};
      let scheduledRefreshTimer = null;

      if (window.Chart) {
        Chart.defaults.font.family = '"IBM Plex Sans", "SF Pro Text", "Segoe UI", sans-serif';
        Chart.defaults.color = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
      }

      dom.refreshBtn.addEventListener('click', () => refreshPrices({ skipIfFresh: true }));
      const bootCache = readLocalCache();
      if (isCacheFresh(bootCache)) {
        render(bootCache.payload);
        const cachedSummary = summarizeErrors(bootCache.payload?.errors, bootCache.payload?.symbols?.length);
        const cachedNotice = bootCache.payload?.notice;
        if (cachedSummary.failedSymbols.length) {
          setStatus(`Using cached data. ${cachedSummary.summary || 'Some symbols unavailable.'}`, 'warn');
          renderErrorPanel(cachedSummary);
        } else if (cachedNotice) {
          setStatus(cachedNotice, 'muted');
          renderErrorPanel(null);
        } else {
          const nextRefresh = new Date(bootCache.fetchedAtMs + bootCache.ttlMs);
          setStatus(`Using cached data. Next refresh ${formatDateTime(nextRefresh)}.`, 'muted');
          renderErrorPanel(null);
        }
      }
      updateRefreshState();
      if (bootCache?.payload?.partial) {
        scheduleNextRefresh(bootCache.payload);
      }
      window.setInterval(updateRefreshState, 60 * 1000);
      refreshPrices({ silent: true, skipIfFresh: true });

      function formatPercent(value) {
        if (typeof value !== 'number' || Number.isNaN(value)) return '--';
        const sign = value > 0 ? '+' : '';
        return `${sign}${value.toFixed(2)}%`;
      }

      function formatTime(value) {
        return value.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      function formatDate(value) {
        return value.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
      }

      function formatDateTime(value) {
        return `${formatDate(value)} ${formatTime(value)}`;
      }

      function getCacheTtlMs(payload) {
        const ttlSeconds = Number(payload?.cacheTtlSeconds);
        if (Number.isFinite(ttlSeconds) && ttlSeconds > 0) {
          return ttlSeconds * 1000;
        }
        return FALLBACK_TTL_MS;
      }

      function readLocalCache() {
        try {
          const raw = localStorage.getItem(LOCAL_CACHE_KEY);
          if (!raw) return null;
          const payload = JSON.parse(raw);
          const fetchedAtMs = Date.parse(payload?.fetchedAt);
          if (!Number.isFinite(fetchedAtMs)) return null;
          const ttlMs = getCacheTtlMs(payload);
          return {
            payload,
            fetchedAtMs,
            ttlMs
          };
        } catch (error) {
          return null;
        }
      }

      function isCacheFresh(cache) {
        if (!cache) return false;
        return Date.now() - cache.fetchedAtMs < cache.ttlMs;
      }

      function writeLocalCache(payload) {
        try {
          localStorage.setItem(LOCAL_CACHE_KEY, JSON.stringify(payload));
        } catch (error) {
          // Ignore storage errors (private mode, quota, etc.)
        }
      }

      function setStatus(message, level) {
        dom.statusLine.textContent = message || '';
        dom.statusLine.dataset.level = level || 'muted';
        if (message && level === 'ok') {
          window.clearTimeout(setStatus.timer);
          setStatus.timer = window.setTimeout(() => {
            dom.statusLine.textContent = '';
          }, 3000);
        }
      }

      function updateRefreshState({ forceDisabled } = {}) {
        if (!dom.refreshBtn) return;
        if (forceDisabled) {
          dom.refreshBtn.disabled = true;
          return;
        }
        const cache = readLocalCache();
        if (isCacheFresh(cache)) {
          if (cache?.payload?.partial && cache.payload?.nextFetchAfter) {
            const nextBatch = new Date(cache.payload.nextFetchAfter);
            dom.refreshBtn.disabled = true;
            dom.refreshBtn.title = `Next batch ${formatDateTime(nextBatch)}.`;
            return;
          }
          const nextRefresh = new Date(cache.fetchedAtMs + cache.ttlMs);
          dom.refreshBtn.disabled = true;
          dom.refreshBtn.title = `Refresh available ${formatDateTime(nextRefresh)}.`;
        } else {
          dom.refreshBtn.disabled = false;
          dom.refreshBtn.title = 'Refresh prices';
        }
      }

      function scheduleNextRefresh(payload) {
        if (scheduledRefreshTimer) {
          window.clearTimeout(scheduledRefreshTimer);
          scheduledRefreshTimer = null;
        }
        if (!payload?.partial) return;
        const nextFetchMs = Date.parse(payload?.nextFetchAfter);
        if (!Number.isFinite(nextFetchMs)) return;
        const delayMs = Math.max(0, nextFetchMs - Date.now());
        scheduledRefreshTimer = window.setTimeout(() => {
          refreshPrices({ silent: true, skipIfFresh: true });
        }, delayMs);
      }

      function normalizeErrorEntry(value) {
        if (!value) return null;
        if (typeof value === 'string') return { message: value };
        if (typeof value === 'object') {
          return {
            message: value.message || value.error || 'Unknown error',
            code: value.code,
            status: value.status
          };
        }
        return { message: String(value) };
      }

      function summarizeErrors(errors, totalSymbols) {
        const entries = Object.entries(errors || {})
          .map(([symbol, value]) => {
            const normalized = normalizeErrorEntry(value);
            return normalized ? { symbol, ...normalized } : null;
          })
          .filter(Boolean);
        const failedSymbols = entries.map((entry) => entry.symbol);
        const uniqueMessages = Array.from(new Set(entries.map((entry) => entry.message)));
        const allFailed = totalSymbols ? failedSymbols.length === totalSymbols : false;
        let summary = '';
        if (allFailed && uniqueMessages.length === 1) {
          summary = `All symbols failed: ${uniqueMessages[0]}`;
        } else if (allFailed && uniqueMessages.length > 1) {
          summary = 'All symbols failed (multiple errors). Check console for details.';
        } else if (uniqueMessages.length === 1 && failedSymbols.length) {
          summary = `Some symbols unavailable (${uniqueMessages[0]}): ${failedSymbols.join(', ')}`;
        } else if (failedSymbols.length) {
          summary = `Some symbols unavailable (multiple errors): ${failedSymbols.join(', ')}`;
        }
        return { entries, failedSymbols, uniqueMessages, allFailed, summary };
      }

      function renderErrorPanel(summary) {
        if (!dom.errorPanel) return;
        dom.errorPanel.innerHTML = '';
        dom.errorPanel.classList.remove('active');
        if (!summary || !summary.entries.length) return;

        dom.errorPanel.classList.add('active');
        const title = document.createElement('h3');
        title.textContent = 'Data fetch errors';
        dom.errorPanel.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'error-meta';
        if (summary.uniqueMessages.length === 1) {
          meta.textContent = `Reason: ${summary.uniqueMessages[0]}`;
        } else {
          meta.textContent = 'Multiple error reasons returned by provider.';
        }
        dom.errorPanel.appendChild(meta);

        const list = document.createElement('ul');
        summary.entries.forEach((entry) => {
          const item = document.createElement('li');
          const parts = [`${entry.symbol}: ${entry.message}`];
          const detailParts = [];
          if (entry.code) detailParts.push(`code ${entry.code}`);
          if (entry.status) detailParts.push(`status ${entry.status}`);
          if (detailParts.length) {
            parts.push(`(${detailParts.join(', ')})`);
          }
          item.textContent = parts.join(' ');
          list.appendChild(item);
        });
        dom.errorPanel.appendChild(list);
      }

      async function refreshPrices({ silent, skipIfFresh, force } = {}) {
        if (isRefreshing) return;

        const localCache = readLocalCache();
        if (!force && skipIfFresh && isCacheFresh(localCache)) {
          const summary = summarizeErrors(localCache.payload?.errors, localCache.payload?.symbols?.length);
          const nextBatch = localCache?.payload?.partial && localCache.payload?.nextFetchAfter
            ? new Date(localCache.payload.nextFetchAfter)
            : null;
          const notice = localCache?.payload?.notice;
          if (!silent) {
            if (summary.failedSymbols.length) {
              const suffix = nextBatch ? ` Next batch ${formatDateTime(nextBatch)}.` : '';
              setStatus(`Using cached data. ${summary.summary || 'Some symbols unavailable.'}${suffix}`, 'warn');
            } else if (notice) {
              setStatus(notice, 'muted');
            } else {
              if (nextBatch) {
                setStatus(`Using cached data. Next batch ${formatDateTime(nextBatch)}.`, 'muted');
              } else {
                const nextRefresh = new Date(localCache.fetchedAtMs + localCache.ttlMs);
                setStatus(`Using cached data. Next refresh ${formatDateTime(nextRefresh)}.`, 'muted');
              }
            }
          }
          if (summary.failedSymbols.length) {
            renderErrorPanel(summary);
          } else {
            renderErrorPanel(null);
          }
          scheduleNextRefresh(localCache.payload);
          return;
        }

        isRefreshing = true;
        updateRefreshState({ forceDisabled: true });
        if (!silent) {
          setStatus('Refreshing prices...', 'muted');
        }

        try {
          const payload = await fetchLeagueData();
          if (payload?.error) {
            throw new Error(payload.error);
          }
          render(payload);
          const hasSeries = Object.keys(payload?.series || {}).length > 0;
          const shouldCache = hasSeries || payload?.notice || payload?.partial;
          if (shouldCache) {
            writeLocalCache(payload);
          }
          const summary = summarizeErrors(payload?.errors, payload?.symbols?.length);
          const nextBatch = payload?.partial && payload?.nextFetchAfter
            ? new Date(payload.nextFetchAfter)
            : null;
          const notice = payload?.notice;
          if (summary.failedSymbols.length) {
            const suffix = nextBatch ? ` Next batch ${formatDateTime(nextBatch)}.` : '';
            setStatus(`${summary.summary || 'Some symbols unavailable.'}${suffix}`, 'warn');
            renderErrorPanel(summary);
            console.warn('Price fetch errors', summary.entries);
          } else if (notice) {
            setStatus(notice, 'muted');
            renderErrorPanel(null);
          } else {
            if (!silent) {
              if (nextBatch) {
                setStatus(`Batch updated. Next batch ${formatDateTime(nextBatch)}.`, 'muted');
              } else {
                setStatus('Prices updated.', 'ok');
              }
            }
            renderErrorPanel(null);
          }
          scheduleNextRefresh(payload);
        } catch (error) {
          const message = error?.message || 'Price refresh failed. Check the API key.';
          const fallback = readLocalCache();
          if (fallback?.payload) {
            render(fallback.payload);
            setStatus(`Using cached data (refresh failed: ${message}).`, 'warn');
            renderErrorPanel(null);
            scheduleNextRefresh(fallback.payload);
            return;
          }
          setStatus(message, 'warn');
          renderErrorPanel(null);
        } finally {
          isRefreshing = false;
          updateRefreshState();
        }
      }

      async function fetchLeagueData() {
        const response = await fetch(API_ENDPOINT, { cache: 'no-store' });
        const payload = await response.json().catch(() => null);
        if (!response.ok) {
          const message = payload?.error || 'League data unavailable';
          const details = payload?.details ? ` ${payload.details}` : '';
          throw new Error(`${message}${details}`);
        }
        return payload;
      }

      function normalizeSeries(values) {
        if (!Array.isArray(values)) return [];
        return values
          .map((item) => {
            const rawDate = item?.date || item?.datetime;
            const close = Number(item?.close);
            if (!rawDate || !Number.isFinite(close)) return null;
            return { date: rawDate.slice(0, 10), close };
          })
          .filter(Boolean)
          .sort((a, b) => a.date.localeCompare(b.date));
      }

      function prepareSeries(rawSeries) {
        const seriesByTicker = {};
        const mapsByTicker = {};
        const dateSet = new Set();

        Object.entries(rawSeries || {}).forEach(([symbol, values]) => {
          const normalized = normalizeSeries(values);
          seriesByTicker[symbol] = normalized;
          const map = new Map();
          normalized.forEach((point) => {
            map.set(point.date, point.close);
            dateSet.add(point.date);
          });
          mapsByTicker[symbol] = map;
        });

        return {
          seriesByTicker,
          mapsByTicker,
          labels: Array.from(dateSet).sort()
        };
      }

      function computeReturn(start, current) {
        if (!Number.isFinite(start) || !Number.isFinite(current) || start === 0) return null;
        return ((current - start) / start) * 100;
      }

      function computeStats(seriesByTicker) {
        return PARTICIPANTS.map((participant) => {
          const [tickerOne, tickerTwo] = participant.tickers;
          const seriesOne = seriesByTicker[tickerOne] || [];
          const seriesTwo = seriesByTicker[tickerTwo] || [];
          const startOne = seriesOne[0]?.close ?? null;
          const startTwo = seriesTwo[0]?.close ?? null;
          const currentOne = seriesOne[seriesOne.length - 1]?.close ?? null;
          const currentTwo = seriesTwo[seriesTwo.length - 1]?.close ?? null;
          const returnOne = computeReturn(startOne, currentOne);
          const returnTwo = computeReturn(startTwo, currentTwo);
          const avgReturn = returnOne != null && returnTwo != null
            ? (returnOne + returnTwo) / 2
            : null;

          let bestStock = null;
          if (returnOne != null && returnTwo != null) {
            bestStock = returnOne >= returnTwo
              ? { ticker: tickerOne, value: returnOne }
              : { ticker: tickerTwo, value: returnTwo };
          }

          return {
            ...participant,
            avgReturn,
            bestStock,
            startPrices: {
              [tickerOne]: startOne,
              [tickerTwo]: startTwo
            }
          };
        });
      }

      function render(payload) {
        const prepared = prepareSeries(payload?.series || {});
        const stats = computeStats(prepared.seriesByTicker);
        const ranked = stats
          .slice()
          .sort((a, b) => (b.avgReturn ?? -Infinity) - (a.avgReturn ?? -Infinity))
          .map((participant, index) => ({
            ...participant,
            rank: index + 1
          }));

        const lockDate = payload?.startDate || LEAGUE_START_DATE;
        renderLeaderCard(ranked[0], lockDate);
        renderLeaderboard(ranked);
        renderCharts(ranked, prepared);

        dom.lastUpdated.textContent = payload?.fetchedAt
          ? formatTime(new Date(payload.fetchedAt))
          : '--:--';
        dom.lockDate.textContent = lockDate
          ? formatDate(new Date(lockDate))
          : '--';
      }

      function renderLeaderCard(leader, lockDate) {
        if (!leader) {
          dom.leaderCard.classList.add('empty');
          dom.leaderName.textContent = 'No participants yet';
          dom.leaderReturn.textContent = '--%';
          dom.leaderAvg.textContent = '--%';
          dom.leaderBest.textContent = '--';
          dom.leaderStart.textContent = '--';
          dom.leaderCrown.innerHTML = '';
          dom.leaderReturn.classList.remove('positive', 'negative');
          return;
        }

        dom.leaderCard.classList.remove('empty');
        dom.leaderCrown.innerHTML = crownSvg(18);
        dom.leaderName.textContent = leader.name;
        dom.leaderReturn.textContent = formatPercent(leader.avgReturn);
        dom.leaderAvg.textContent = formatPercent(leader.avgReturn);
        dom.leaderBest.textContent = leader.bestStock
          ? `${leader.bestStock.ticker} ${formatPercent(leader.bestStock.value)}`
          : '--';
        dom.leaderStart.textContent = lockDate
          ? formatDate(new Date(lockDate))
          : '--';

        dom.leaderReturn.classList.toggle('positive', leader.avgReturn > 0);
        dom.leaderReturn.classList.toggle('negative', leader.avgReturn < 0);
      }

      function renderLeaderboard(ranked) {
        dom.leaderboardBody.innerHTML = '';
        if (!ranked.length) {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 4;
          cell.className = 'empty-state';
          cell.textContent = 'Waiting for price data.';
          row.appendChild(cell);
          dom.leaderboardBody.appendChild(row);
          return;
        }

        const nextRanks = {};

        ranked.forEach((participant) => {
          nextRanks[participant.id] = participant.rank;
          const row = document.createElement('tr');
          if (participant.rank === 1) {
            row.classList.add('leader-row');
          }
          if (lastRanks[participant.id] && lastRanks[participant.id] !== participant.rank) {
            row.classList.add('rank-change');
          }

          const rankCell = document.createElement('td');
          const rankPill = document.createElement('div');
          rankPill.className = 'rank-pill';
          if (participant.rank === 1) {
            const crown = document.createElement('span');
            crown.innerHTML = crownSvg(14);
            rankPill.appendChild(crown);
          }
          const rankText = document.createElement('span');
          rankText.textContent = participant.rank;
          rankPill.appendChild(rankText);
          rankCell.appendChild(rankPill);

          const nameCell = document.createElement('td');
          nameCell.className = 'name-cell';
          const nameText = document.createElement('div');
          nameText.className = 'name';
          nameText.textContent = participant.name;
          const tickerText = document.createElement('div');
          tickerText.className = 'tickers';
          tickerText.textContent = participant.tickers.join(' â€¢ ');
          nameCell.appendChild(nameText);
          nameCell.appendChild(tickerText);

          const avgCell = document.createElement('td');
          avgCell.className = 'avg-return';
          avgCell.textContent = formatPercent(participant.avgReturn);
          avgCell.classList.toggle('positive', participant.avgReturn > 0);
          avgCell.classList.toggle('negative', participant.avgReturn < 0);

          const bestCell = document.createElement('td');
          if (participant.bestStock) {
            const badge = document.createElement('span');
            badge.className = 'badge';
            if (participant.bestStock.value < 0) {
              badge.classList.add('negative');
            }
            badge.textContent = `Best: ${participant.bestStock.ticker} ${formatPercent(participant.bestStock.value)}`;
            bestCell.appendChild(badge);
          } else {
            bestCell.textContent = '--';
          }

          row.appendChild(rankCell);
          row.appendChild(nameCell);
          row.appendChild(avgCell);
          row.appendChild(bestCell);

          dom.leaderboardBody.appendChild(row);
        });

        lastRanks = nextRanks;
      }

      function renderCharts(ranked, prepared) {
        if (!window.Chart) return;
        if (!prepared.labels.length) return;

        const trimmedLabels = prepared.labels.slice(-MAX_HISTORY);
        const labels = trimmedLabels.map((value) => {
          const date = new Date(`${value}T00:00:00`);
          return `${date.toLocaleDateString([], { month: 'short', day: 'numeric' })}`;
        });

        const barLabels = ranked.map((participant) => participant.name);
        const barValues = ranked.map((participant) => participant.avgReturn);
        const barColors = barValues.map((value) => {
          if (value == null) return '#c9ced6';
          return value >= 0 ? '#0a7a4b' : '#b33b2e';
        });

        if (!barChartInstance) {
          barChartInstance = new Chart(dom.barChart, {
            type: 'bar',
            data: {
              labels: barLabels,
              datasets: [
                {
                  data: barValues,
                  backgroundColor: barColors,
                  borderRadius: 8
                }
              ]
            },
            options: chartOptions('%')
          });
        } else {
          barChartInstance.data.labels = barLabels;
          barChartInstance.data.datasets[0].data = barValues;
          barChartInstance.data.datasets[0].backgroundColor = barColors;
          barChartInstance.update();
        }

        const lineDatasets = ranked.map((participant, index) => {
          const color = chartColors[index % chartColors.length];
          const [tickerOne, tickerTwo] = participant.tickers;
          const mapOne = prepared.mapsByTicker[tickerOne] || new Map();
          const mapTwo = prepared.mapsByTicker[tickerTwo] || new Map();
          const startOne = prepared.seriesByTicker[tickerOne]?.[0]?.close ?? null;
          const startTwo = prepared.seriesByTicker[tickerTwo]?.[0]?.close ?? null;
          const data = trimmedLabels.map((date) => {
            const priceOne = mapOne.get(date);
            const priceTwo = mapTwo.get(date);
            const returnOne = computeReturn(startOne, priceOne);
            const returnTwo = computeReturn(startTwo, priceTwo);
            if (returnOne == null || returnTwo == null) return null;
            return (returnOne + returnTwo) / 2;
          });

          return {
            label: participant.name,
            data,
            borderColor: color,
            backgroundColor: `${color}20`,
            borderWidth: 2,
            tension: 0.3,
            spanGaps: true
          };
        });

        if (!lineChartInstance) {
          lineChartInstance = new Chart(dom.lineChart, {
            type: 'line',
            data: {
              labels,
              datasets: lineDatasets
            },
            options: chartOptions('%', true)
          });
        } else {
          lineChartInstance.data.labels = labels;
          lineChartInstance.data.datasets = lineDatasets;
          lineChartInstance.update();
        }
      }

      function chartOptions(unit, showLegend) {
        const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid').trim();
        return {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: showLegend,
              position: 'bottom',
              labels: {
                usePointStyle: true,
                boxWidth: 8
              }
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const value = context.parsed.y;
                  if (value == null) return 'No data';
                  return `${context.dataset.label}: ${value.toFixed(2)}${unit}`;
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                display: false
              },
              ticks: {
                maxRotation: 0,
                autoSkip: true,
                maxTicksLimit: 6
              }
            },
            y: {
              grid: {
                color: gridColor
              },
              ticks: {
                callback: (value) => `${value}${unit}`
              }
            }
          }
        };
      }

      function crownSvg(size) {
        return `
          <svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M4 8.5L8.5 11.5L12 6L15.5 11.5L20 8.5L18.5 18H5.5L4 8.5Z" stroke="currentColor" stroke-width="1.4" fill="none" />
            <path d="M6 18H18" stroke="currentColor" stroke-width="1.4" />
          </svg>
        `;
      }
    })();
  </script>

</body>
</html>
